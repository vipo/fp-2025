<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Lessons.Lesson07</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption empty">&nbsp;</span><ul class="links" id="page-menu"><li><a href="src/Lessons.Lesson07.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr></table><p class="caption">Lessons.Lesson07</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Notes taken by Emilija Rim&#353;elyt&#279;</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:lc">lc</a> :: [(Integer, Char)]</li><li class="src short"><a href="#v:lc-39-">lc'</a> :: [Integer]</li><li class="src short"><a href="#v:lc-39--39-">lc''</a> :: [Integer]</li><li class="src short"><a href="#v:lc-39--39--39-">lc'''</a> :: [Integer]</li><li class="src short"><a href="#v:lc-39--39--39--39-">lc''''</a> :: [Integer]</li><li class="src short"><a href="#v:lm">lm</a> :: [(Integer, Char)]</li><li class="src short"><a href="#v:lm-39-">lm'</a> :: [(Integer, Char)]</li><li class="src short"><a href="#v:mm">mm</a> :: Maybe Integer</li><li class="src short"><a href="#v:mm-39-">mm'</a> :: Maybe Integer</li><li class="src short"><a href="#v:mm-39--39-">mm''</a> :: Maybe Integer</li><li class="src short"><a href="#v:em">em</a> :: Either String Char</li><li class="src short"><a href="#v:em-39-">em'</a> :: Either String Char</li><li class="src short"><a href="#v:em-39--39-">em''</a> :: Either String (Integer, Char)</li><li class="src short"><a href="#v:em-39--39--39-">em'''</a> :: Either Integer Integer</li><li class="src short"><a href="#v:lmb">lmb</a> :: [(Integer, Char)]</li><li class="src short"><a href="#v:mmb">mmb</a> :: Maybe Integer</li><li class="src short"><a href="#v:emb">emb</a> :: Either String Char</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:lc" class="def">lc</a> :: [(Integer, Char)] <a href="src/Lessons.Lesson07.html#lc" class="link">Source</a> <a href="#v:lc" class="selflink">#</a></p><div class="doc"><p>List comprehension: pairing numbers with letters.
 For each <code>a</code> and <code>b</code>, we build a tuple.
 A cartesian product, clean and subtle.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>lc
</code></strong>[(1,'a'),(1,'b'),(2,'a'),(2,'b'),(3,'a'),(3,'b'),(4,'a'),(4,'b')]
</pre></div></div><div class="top"><p class="src"><a id="v:lc-39-" class="def">lc'</a> :: [Integer] <a href="src/Lessons.Lesson07.html#lc%27" class="link">Source</a> <a href="#v:lc-39-" class="selflink">#</a></p><div class="doc"><p>Squares of <code>a</code>, repeated for each <code>b</code>.
 <code>b</code> isn&#8217;t used, but it multiplies the count.
 More combinations &#8212; that&#8217;s the amount.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>lc'
</code></strong>[1,1,4,4,9,9]
</pre></div></div><div class="top"><p class="src"><a id="v:lc-39--39-" class="def">lc''</a> :: [Integer] <a href="src/Lessons.Lesson07.html#lc%27%27" class="link">Source</a> <a href="#v:lc-39--39-" class="selflink">#</a></p><div class="doc"><p><code>b</code> repeats for each <code>c</code>, though <code>c</code> is unused.
 <code>a</code> is fixed, but nesting boosts the size.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>lc''
</code></strong>[1,1,2,2,3,3,4,4]
</pre></div></div><div class="top"><p class="src"><a id="v:lc-39--39--39-" class="def">lc'''</a> :: [Integer] <a href="src/Lessons.Lesson07.html#lc%27%27%27" class="link">Source</a> <a href="#v:lc-39--39--39-" class="selflink">#</a></p><div class="doc"><p>Empty list in <code>b</code> means no results.
 Comprehension short-circuits &#8212; nothing to compute.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>lc'''
</code></strong>[]
</pre></div></div><div class="top"><p class="src"><a id="v:lc-39--39--39--39-" class="def">lc''''</a> :: [Integer] <a href="src/Lessons.Lesson07.html#lc%27%27%27%27" class="link">Source</a> <a href="#v:lc-39--39--39--39-" class="selflink">#</a></p><div class="doc"><p>Same idea, but now <code>a</code> is empty.
 No values to pair, so the list stays bare.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>lc''''
</code></strong>[]
</pre></div></div><div class="top"><p class="src"><a id="v:lm" class="def">lm</a> :: [(Integer, Char)] <a href="src/Lessons.Lesson07.html#lm" class="link">Source</a> <a href="#v:lm" class="selflink">#</a></p><div class="doc"><p>Do-notation version of <code><a href="Lessons-Lesson07.html#v:lc" title="Lessons.Lesson07">lc</a></code>.
 Same result, just written differently.
 Shows how monads can express list logic.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>lm
</code></strong>[(1,'a'),(1,'b'),(2,'a'),(2,'b'),(3,'a'),(3,'b'),(4,'a'),(4,'b')]
</pre></div></div><div class="top"><p class="src"><a id="v:lm-39-" class="def">lm'</a> :: [(Integer, Char)] <a href="src/Lessons.Lesson07.html#lm%27" class="link">Source</a> <a href="#v:lm-39-" class="selflink">#</a></p><div class="doc"><p>Swapping the order changes the output.
 First <code>b</code>, then <code>a</code> &#8212; so the nesting flips.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>lm'
</code></strong>[(1,'a'),(2,'a'),(3,'a'),(4,'a'),(1,'b'),(2,'b'),(3,'b'),(4,'b')]
</pre></div></div><div class="top"><p class="src"><a id="v:mm" class="def">mm</a> :: Maybe Integer <a href="src/Lessons.Lesson07.html#mm" class="link">Source</a> <a href="#v:mm" class="selflink">#</a></p><div class="doc"><p>Maybe monad: chaining computations.
 All values must be <code>Just</code>, or the chain breaks.
 One <code>Nothing</code>, and the whole thing shakes.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>mm
</code></strong>Just 84
</pre></div></div><div class="top"><p class="src"><a id="v:mm-39-" class="def">mm'</a> :: Maybe Integer <a href="src/Lessons.Lesson07.html#mm%27" class="link">Source</a> <a href="#v:mm-39-" class="selflink">#</a></p><div class="doc"><p>One <code>Nothing</code> in the chain &#8212; result is <code>Nothing</code>.
 That&#8217;s how Maybe guards against failure.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>mm'
</code></strong>Nothing
</pre></div></div><div class="top"><p class="src"><a id="v:mm-39--39-" class="def">mm''</a> :: Maybe Integer <a href="src/Lessons.Lesson07.html#mm%27%27" class="link">Source</a> <a href="#v:mm-39--39-" class="selflink">#</a></p><div class="doc"><p>Looks like it should work, but it doesn&#8217;t.
 You need to bind the final value too.
 Just expression alone won&#8217;t pull it through.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>mm''
</code></strong>Nothing
</pre></div></div><div class="top"><p class="src"><a id="v:em" class="def">em</a> :: Either String Char <a href="src/Lessons.Lesson07.html#em" class="link">Source</a> <a href="#v:em" class="selflink">#</a></p><div class="doc"><p>Either monad: <code>Right</code> flows like Maybe&#8217;s <code>Just</code>.
 <code>Left</code> short-circuits &#8212; it&#8217;s an error path.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>em
</code></strong>Right 'a'
</pre></div></div><div class="top"><p class="src"><a id="v:em-39-" class="def">em'</a> :: Either String Char <a href="src/Lessons.Lesson07.html#em%27" class="link">Source</a> <a href="#v:em-39-" class="selflink">#</a></p><div class="doc"><p><code>Left</code> stops the computation early.
 Doesn&#8217;t matter what comes after &#8212; it&#8217;s done.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>em'
</code></strong>Left &quot;oh&quot;
</pre></div></div><div class="top"><p class="src"><a id="v:em-39--39-" class="def">em''</a> :: Either String (Integer, Char) <a href="src/Lessons.Lesson07.html#em%27%27" class="link">Source</a> <a href="#v:em-39--39-" class="selflink">#</a></p><div class="doc"><p>You can return tuples too &#8212; Either handles it.
 As long as all are <code>Right</code>, it&#8217;s alright.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>em''
</code></strong>Right (43,'a')
</pre></div></div><div class="top"><p class="src"><a id="v:em-39--39--39-" class="def">em'''</a> :: Either Integer Integer <a href="src/Lessons.Lesson07.html#em%27%27%27" class="link">Source</a> <a href="#v:em-39--39--39-" class="selflink">#</a></p><div class="doc"><p>Mixing <code>Left</code> and <code>Right</code> &#8212; <code>Left</code> wins.
 Error takes over, no multiplication begins.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>em'''
</code></strong>Left 42
</pre></div></div><div class="top"><p class="src"><a id="v:lmb" class="def">lmb</a> :: [(Integer, Char)] <a href="src/Lessons.Lesson07.html#lmb" class="link">Source</a> <a href="#v:lmb" class="selflink">#</a></p><div class="doc"><p>Same as <code><a href="Lessons-Lesson07.html#v:lm" title="Lessons.Lesson07">lm</a></code>, but using <code>&gt;&gt;=</code> explicitly.
 Do-notation is just syntactic sugar.
 Shows the plumbing under the rug.</p></div></div><div class="top"><p class="src"><a id="v:mmb" class="def">mmb</a> :: Maybe Integer <a href="src/Lessons.Lesson07.html#mmb" class="link">Source</a> <a href="#v:mmb" class="selflink">#</a></p><div class="doc"><p>Same as <code><a href="Lessons-Lesson07.html#v:mm" title="Lessons.Lesson07">mm</a></code>, but written with <code>&gt;&gt;=</code>.
 Shows how monads chain computations.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>mmb
</code></strong>Just 84
</pre></div></div><div class="top"><p class="src"><a id="v:emb" class="def">emb</a> :: Either String Char <a href="src/Lessons.Lesson07.html#emb" class="link">Source</a> <a href="#v:emb" class="selflink">#</a></p><div class="doc"><p>Same as <code><a href="Lessons-Lesson07.html#v:em" title="Lessons.Lesson07">em</a></code>, but with explicit binds.
 Monads let you sequence effects &#8212; even errors.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.2</p></div></body></html>