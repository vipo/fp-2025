<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Lessons.Lesson07</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption empty">&nbsp;</span><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr></table><p class="caption">Lessons.Lesson07</p></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:lc">lc</a> :: [(Integer, Char)]</li><li class="src short"><a href="#v:lc-39-">lc'</a> :: [Integer]</li><li class="src short"><a href="#v:lc-39--39-">lc''</a> :: [Integer]</li><li class="src short"><a href="#v:lc-39--39--39-">lc'''</a> :: [Integer]</li><li class="src short"><a href="#v:lc-39--39--39--39-">lc''''</a> :: [Integer]</li><li class="src short"><a href="#v:lm">lm</a> :: [(Integer, Char)]</li><li class="src short"><a href="#v:lm-39-">lm'</a> :: [(Integer, Char)]</li><li class="src short"><a href="#v:mm">mm</a> :: Maybe Integer</li><li class="src short"><a href="#v:mm-39-">mm'</a> :: Maybe Integer</li><li class="src short"><a href="#v:mm-39--39-">mm''</a> :: Maybe Integer</li><li class="src short"><a href="#v:em">em</a> :: Either String Char</li><li class="src short"><a href="#v:em-39-">em'</a> :: Either String Char</li><li class="src short"><a href="#v:em-39--39-">em''</a> :: Either String (Integer, Char)</li><li class="src short"><a href="#v:em-39--39--39-">em'''</a> :: Either Integer Integer</li><li class="src short"><a href="#v:lmb">lmb</a> :: [(Integer, Char)]</li><li class="src short"><a href="#v:mmb">mmb</a> :: Maybe Integer</li><li class="src short"><a href="#v:emb">emb</a> :: Either String Char</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:lc" class="def">lc</a> :: [(Integer, Char)] <a href="#v:lc" class="selflink">#</a></p><div class="doc"><p>List comprehension: pairing numbers with letters.
 For each <code>a</code> and <code>b</code>, we build a tuple.
 A cartesian product, clean and subtle.
 &gt;&gt;&gt; lc 
 [(1,<code>a</code>),(1,<code>b</code>),(2,<code>a</code>),(2,<code>b</code>),(3,<code>a</code>),(3,<code>b</code>),(4,<code>a</code>),(4,<code>b</code>)]</p></div></div><div class="top"><p class="src"><a id="v:lc-39-" class="def">lc'</a> :: [Integer] <a href="#v:lc-39-" class="selflink">#</a></p><div class="doc"><p>Squares of <code>a</code>, repeated for each <code>b</code>.
 <code>b</code> isn&#8217;t used, but it multiplies the count.
 More combinations &#8212; that&#8217;s the amount.
 &gt;&gt;&gt; lc'
 [1,1,4,4,9,9]</p></div></div><div class="top"><p class="src"><a id="v:lc-39--39-" class="def">lc''</a> :: [Integer] <a href="#v:lc-39--39-" class="selflink">#</a></p><div class="doc"><p><code>b</code> repeats for each <code>c</code>, though <code>c</code> is unused.
 <code>a</code> is fixed, but nesting boosts the size.
 &gt;&gt;&gt; lc''
 [1,1,2,2,3,3,4,4]</p></div></div><div class="top"><p class="src"><a id="v:lc-39--39--39-" class="def">lc'''</a> :: [Integer] <a href="#v:lc-39--39--39-" class="selflink">#</a></p><div class="doc"><p>Empty list in <code>b</code> means no results.
 Comprehension short-circuits &#8212; nothing to compute.
 &gt;&gt;&gt; lc'''
 []</p></div></div><div class="top"><p class="src"><a id="v:lc-39--39--39--39-" class="def">lc''''</a> :: [Integer] <a href="#v:lc-39--39--39--39-" class="selflink">#</a></p><div class="doc"><p>Same idea, but now <code>a</code> is empty.
 No values to pair, so the list stays bare.
 &gt;&gt;&gt; lc''''
 []</p></div></div><div class="top"><p class="src"><a id="v:lm" class="def">lm</a> :: [(Integer, Char)] <a href="#v:lm" class="selflink">#</a></p><div class="doc"><p>Do-notation version of <code><a href="Lessons-Lesson07.html#v:lc" title="Lessons.Lesson07">lc</a></code>.
 Same result, just written differently.
 Shows how monads can express list logic.
 &gt;&gt;&gt; lm
 [(1,<code>a</code>),(1,<code>b</code>),(2,<code>a</code>),(2,<code>b</code>),(3,<code>a</code>),(3,<code>b</code>),(4,<code>a</code>),(4,<code>b</code>)]</p></div></div><div class="top"><p class="src"><a id="v:lm-39-" class="def">lm'</a> :: [(Integer, Char)] <a href="#v:lm-39-" class="selflink">#</a></p><div class="doc"><p>Swapping the order changes the output.
 First <code>b</code>, then <code>a</code> &#8212; so the nesting flips.
 &gt;&gt;&gt; lm'
 [(1,<code>a</code>),(2,<code>a</code>),(3,<code>a</code>),(4,<code>a</code>),(1,<code>b</code>),(2,<code>b</code>),(3,<code>b</code>),(4,<code>b</code>)]</p></div></div><div class="top"><p class="src"><a id="v:mm" class="def">mm</a> :: Maybe Integer <a href="#v:mm" class="selflink">#</a></p><div class="doc"><p>Maybe monad: chaining computations.
 All values must be <code>Just</code>, or the chain breaks.
 One <code>Nothing</code>, and the whole thing shakes.
 &gt;&gt;&gt; mm
 Just 84</p></div></div><div class="top"><p class="src"><a id="v:mm-39-" class="def">mm'</a> :: Maybe Integer <a href="#v:mm-39-" class="selflink">#</a></p><div class="doc"><p>One <code>Nothing</code> in the chain &#8212; result is <code>Nothing</code>.
 That&#8217;s how Maybe guards against failure.
 &gt;&gt;&gt; mm'
 Nothing</p></div></div><div class="top"><p class="src"><a id="v:mm-39--39-" class="def">mm''</a> :: Maybe Integer <a href="#v:mm-39--39-" class="selflink">#</a></p><div class="doc"><p>Looks like it should work, but it doesn&#8217;t.
 You need to bind the final value too.
 Just expression alone won&#8217;t pull it through.
 &gt;&gt;&gt; mm''
 Nothing</p></div></div><div class="top"><p class="src"><a id="v:em" class="def">em</a> :: Either String Char <a href="#v:em" class="selflink">#</a></p><div class="doc"><p>Either monad: <code>Right</code> flows like Maybe&#8217;s <code>Just</code>.
 <code>Left</code> short-circuits &#8212; it&#8217;s an error path.
 &gt;&gt;&gt; em
 Right <code>a</code></p></div></div><div class="top"><p class="src"><a id="v:em-39-" class="def">em'</a> :: Either String Char <a href="#v:em-39-" class="selflink">#</a></p><div class="doc"><p><code>Left</code> stops the computation early.
 Doesn&#8217;t matter what comes after &#8212; it&#8217;s done.
 &gt;&gt;&gt; em'
 Left &quot;oh&quot;</p></div></div><div class="top"><p class="src"><a id="v:em-39--39-" class="def">em''</a> :: Either String (Integer, Char) <a href="#v:em-39--39-" class="selflink">#</a></p><div class="doc"><p>You can return tuples too &#8212; Either handles it.
 As long as all are <code>Right</code>, it&#8217;s alright.</p></div></div><div class="top"><p class="src"><a id="v:em-39--39--39-" class="def">em'''</a> :: Either Integer Integer <a href="#v:em-39--39--39-" class="selflink">#</a></p><div class="doc"><p>Mixing <code>Left</code> and <code>Right</code> &#8212; <code>Left</code> wins.
 Error takes over, no multiplication begins.
 &gt;&gt;&gt; em'''
 Left 42</p></div></div><div class="top"><p class="src"><a id="v:lmb" class="def">lmb</a> :: [(Integer, Char)] <a href="#v:lmb" class="selflink">#</a></p><div class="doc"><p>Same as <code><a href="Lessons-Lesson07.html#v:lm" title="Lessons.Lesson07">lm</a></code>, but using <code>&gt;&gt;=</code> explicitly.
 Do-notation is just syntactic sugar.
 Shows the plumbing under the rug.</p></div></div><div class="top"><p class="src"><a id="v:mmb" class="def">mmb</a> :: Maybe Integer <a href="#v:mmb" class="selflink">#</a></p><div class="doc"><p>Same as <code><a href="Lessons-Lesson07.html#v:mm" title="Lessons.Lesson07">mm</a></code>, but written with <code>&gt;&gt;=</code>.
 Shows how monads chain computations.
 &gt;&gt;&gt; mmb
 Just 84</p></div></div><div class="top"><p class="src"><a id="v:emb" class="def">emb</a> :: Either String Char <a href="#v:emb" class="selflink">#</a></p><div class="doc"><p>Same as <code><a href="Lessons-Lesson07.html#v:em" title="Lessons.Lesson07">em</a></code>, but with explicit binds.
 Monads let you sequence effects &#8212; even errors.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.2</p></div></body></html>